// Code generated by protoc-gen-go. DO NOT EDIT.
// source: pkg/rpc/datastore/service.proto

/*
Package datastore is a generated protocol buffer package.

It is generated from these files:
	pkg/rpc/datastore/service.proto

It has these top-level messages:
	WriteRequest
	WriteResponse
	ReadRequest
	EncryptedEvent
	ReadResponse
*/
package datastore

import proto "github.com/golang/protobuf/proto"
import fmt "fmt"
import math "math"
import google_protobuf "github.com/golang/protobuf/ptypes/timestamp"

// Reference imports to suppress errors if they are not otherwise used.
var _ = proto.Marshal
var _ = fmt.Errorf
var _ = math.Inf

// This is a compile-time assertion to ensure that this generated file
// is compatible with the proto package it is being compiled against.
// A compilation error at this line likely means your copy of the
// proto package needs to be updated.
const _ = proto.ProtoPackageIsVersion2 // please upgrade the proto package

// WriteRequest is the message we send to the store in order to write encrypted
// data for particular user.
type WriteRequest struct {
	// The public key for a consumer for which the included data has been
	// encrypted.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// The encrypted data comprising the event to be stored. This data is
	// completely opaque to the data store, so is represented as just an
	// arbitrary sequence of bytes.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *WriteRequest) Reset()                    { *m = WriteRequest{} }
func (m *WriteRequest) String() string            { return proto.CompactTextString(m) }
func (*WriteRequest) ProtoMessage()               {}
func (*WriteRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{0} }

func (m *WriteRequest) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *WriteRequest) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// WriteResponse is a placeholder response message returned from the call to
// the service. Currently it is empty as we have not identified any fields that
// should be returned, however we keep as a type under our control such that
// should such a need be identified in the future, this type can be extended to
// include those fields.
type WriteResponse struct {
}

func (m *WriteResponse) Reset()                    { *m = WriteResponse{} }
func (m *WriteResponse) String() string            { return proto.CompactTextString(m) }
func (*WriteResponse) ProtoMessage()               {}
func (*WriteResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{1} }

// ReadRequest is a message sent by a consumer to the service by which
// encrypted data can be requested for a specific user, identified by their
// public key.
type ReadRequest struct {
	// The public key for a consumer for which encrypted data has been stored.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// The start of an interval for which data is being requested.
	StartTime *google_protobuf.Timestamp `protobuf:"bytes,2,opt,name=start_time,json=startTime" json:"start_time,omitempty"`
	// The end of an interval for which data is being requested, represented as
	// Timestamp message. This field is optional and if omitted defaults to 'now'
	EndTime *google_protobuf.Timestamp `protobuf:"bytes,3,opt,name=end_time,json=endTime" json:"end_time,omitempty"`
	// A pagination cursor returned from the call to ReadData that indicates from
	// where data access should continue. This field is optional, if not present
	// it means start from the beginning of the dataset.
	PageCursor string `protobuf:"bytes,4,opt,name=page_cursor,json=pageCursor" json:"page_cursor,omitempty"`
	// Integer value containing the maximum desired number of results within each
	// page of data.
	PageSize int32 `protobuf:"varint,5,opt,name=page_size,json=pageSize" json:"page_size,omitempty"`
}

func (m *ReadRequest) Reset()                    { *m = ReadRequest{} }
func (m *ReadRequest) String() string            { return proto.CompactTextString(m) }
func (*ReadRequest) ProtoMessage()               {}
func (*ReadRequest) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{2} }

func (m *ReadRequest) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *ReadRequest) GetStartTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.StartTime
	}
	return nil
}

func (m *ReadRequest) GetEndTime() *google_protobuf.Timestamp {
	if m != nil {
		return m.EndTime
	}
	return nil
}

func (m *ReadRequest) GetPageCursor() string {
	if m != nil {
		return m.PageCursor
	}
	return ""
}

func (m *ReadRequest) GetPageSize() int32 {
	if m != nil {
		return m.PageSize
	}
	return 0
}

// EncryptedEvent contains a single encrypted event message stored for a
// client. This comprises a timestamp which is the instance the data was
// received and written to storage, along with the encrypted list of bytes
// comprising the message. This message is returned
type EncryptedEvent struct {
	// The time at which this event was recorded expressed in UTC Epoch time.
	Timestamp *google_protobuf.Timestamp `protobuf:"bytes,1,opt,name=timestamp" json:"timestamp,omitempty"`
	// The list of bytes comprising a chunk of encrypted data for a user.
	Data []byte `protobuf:"bytes,2,opt,name=data,proto3" json:"data,omitempty"`
}

func (m *EncryptedEvent) Reset()                    { *m = EncryptedEvent{} }
func (m *EncryptedEvent) String() string            { return proto.CompactTextString(m) }
func (*EncryptedEvent) ProtoMessage()               {}
func (*EncryptedEvent) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{3} }

func (m *EncryptedEvent) GetTimestamp() *google_protobuf.Timestamp {
	if m != nil {
		return m.Timestamp
	}
	return nil
}

func (m *EncryptedEvent) GetData() []byte {
	if m != nil {
		return m.Data
	}
	return nil
}

// ReadResponse is the message returned from our service in response to a
// ReadRequest. Comprises the public key of the user for which the data was
// requested, a repeated list of EncryptedEvent messages comprising the data,
// but also a cursor by which the client can paginate through a large dataset.
// Note we do not attempt to use any streaming functionalities here to simplify
// things, rather we will just allow clients to paginate through datasets to
// obtain the data they need.
type ReadResponse struct {
	// The public of the consumer for which this response struct contains data.
	PublicKey string `protobuf:"bytes,1,opt,name=public_key,json=publicKey" json:"public_key,omitempty"`
	// A string containing a cursor pointing at the next page of encrypted
	// events. Can be used by a client when constructing the next ReadRequest to
	// allow the client to easily consume all results within a time window. If
	// this value is an empty string, then no further pages are available to be
	// requested.
	NextPageCursor string `protobuf:"bytes,2,opt,name=next_page_cursor,json=nextPageCursor" json:"next_page_cursor,omitempty"`
	// A list of EncryptedEvent messages comprising a single page of results
	// within a larger requested dataset.
	Events []*EncryptedEvent `protobuf:"bytes,3,rep,name=events" json:"events,omitempty"`
}

func (m *ReadResponse) Reset()                    { *m = ReadResponse{} }
func (m *ReadResponse) String() string            { return proto.CompactTextString(m) }
func (*ReadResponse) ProtoMessage()               {}
func (*ReadResponse) Descriptor() ([]byte, []int) { return fileDescriptor0, []int{4} }

func (m *ReadResponse) GetPublicKey() string {
	if m != nil {
		return m.PublicKey
	}
	return ""
}

func (m *ReadResponse) GetNextPageCursor() string {
	if m != nil {
		return m.NextPageCursor
	}
	return ""
}

func (m *ReadResponse) GetEvents() []*EncryptedEvent {
	if m != nil {
		return m.Events
	}
	return nil
}

func init() {
	proto.RegisterType((*WriteRequest)(nil), "decode.thingful.datastore.WriteRequest")
	proto.RegisterType((*WriteResponse)(nil), "decode.thingful.datastore.WriteResponse")
	proto.RegisterType((*ReadRequest)(nil), "decode.thingful.datastore.ReadRequest")
	proto.RegisterType((*EncryptedEvent)(nil), "decode.thingful.datastore.EncryptedEvent")
	proto.RegisterType((*ReadResponse)(nil), "decode.thingful.datastore.ReadResponse")
}

func init() { proto.RegisterFile("pkg/rpc/datastore/service.proto", fileDescriptor0) }

var fileDescriptor0 = []byte{
	// 411 bytes of a gzipped FileDescriptorProto
	0x1f, 0x8b, 0x08, 0x00, 0x00, 0x00, 0x00, 0x00, 0x02, 0xff, 0x8c, 0x52, 0xc1, 0x8e, 0xd3, 0x30,
	0x14, 0x54, 0xb6, 0xbb, 0x4b, 0xf3, 0x52, 0x16, 0xe4, 0x53, 0x08, 0x42, 0x8d, 0x72, 0x60, 0xc3,
	0xc5, 0x91, 0x8a, 0x90, 0xe0, 0xb8, 0xc0, 0x9e, 0xb8, 0xa0, 0x2c, 0x12, 0x12, 0x48, 0x8d, 0xdc,
	0xe4, 0x35, 0x44, 0x6d, 0x63, 0x63, 0x3b, 0x15, 0xed, 0xa7, 0xf0, 0x4f, 0xfc, 0x01, 0x1f, 0x83,
	0xec, 0xb4, 0x21, 0x48, 0xd0, 0x70, 0x6b, 0x27, 0x33, 0xa3, 0x99, 0xf1, 0x83, 0xa9, 0x58, 0x95,
	0x89, 0x14, 0x79, 0x52, 0x30, 0xcd, 0x94, 0xe6, 0x12, 0x13, 0x85, 0x72, 0x5b, 0xe5, 0x48, 0x85,
	0xe4, 0x9a, 0x93, 0x47, 0x05, 0xe6, 0xbc, 0x40, 0xaa, 0xbf, 0x54, 0x75, 0xb9, 0x6c, 0xd6, 0xb4,
	0x23, 0x06, 0xd3, 0x92, 0xf3, 0x72, 0x8d, 0x89, 0x25, 0x2e, 0x9a, 0x65, 0xa2, 0xab, 0x0d, 0x2a,
	0xcd, 0x36, 0xa2, 0xd5, 0x46, 0x37, 0x30, 0xf9, 0x28, 0x2b, 0x8d, 0x29, 0x7e, 0x6d, 0x50, 0x69,
	0xf2, 0x04, 0x40, 0x34, 0x8b, 0x75, 0x95, 0x67, 0x2b, 0xdc, 0xf9, 0x4e, 0xe8, 0xc4, 0x6e, 0xea,
	0xb6, 0xc8, 0x3b, 0xdc, 0x11, 0x02, 0xe7, 0xc6, 0xdc, 0x3f, 0x0b, 0x9d, 0x78, 0x92, 0xda, 0xdf,
	0xd1, 0x03, 0xb8, 0x7f, 0xb0, 0x50, 0x82, 0xd7, 0x0a, 0xa3, 0x9f, 0x0e, 0x78, 0x29, 0xb2, 0xe2,
	0x3f, 0x3d, 0x5f, 0x01, 0x28, 0xcd, 0xa4, 0xce, 0x4c, 0x36, 0xeb, 0xec, 0xcd, 0x02, 0xda, 0x06,
	0xa7, 0xc7, 0xe0, 0xf4, 0xc3, 0x31, 0x78, 0xea, 0x5a, 0xb6, 0xf9, 0x4f, 0x5e, 0xc0, 0x18, 0xeb,
	0xa2, 0x15, 0x8e, 0x06, 0x85, 0xf7, 0xb0, 0x2e, 0xac, 0x6c, 0x0a, 0x9e, 0x60, 0x25, 0x66, 0x79,
	0x23, 0x15, 0x97, 0xfe, 0xb9, 0x4d, 0x04, 0x06, 0x7a, 0x63, 0x11, 0xf2, 0x18, 0x5c, 0x4b, 0x50,
	0xd5, 0x1e, 0xfd, 0x8b, 0xd0, 0x89, 0x2f, 0xd2, 0xb1, 0x01, 0xee, 0xaa, 0x3d, 0x46, 0x73, 0xb8,
	0xba, 0xad, 0x73, 0xb9, 0x13, 0x1a, 0x8b, 0xdb, 0x2d, 0xd6, 0x9a, 0xbc, 0x04, 0xb7, 0xdb, 0xd5,
	0xf6, 0x1b, 0x28, 0xd0, 0x91, 0xff, 0xba, 0xe7, 0x77, 0x07, 0x26, 0xed, 0x7c, 0xed, 0x9e, 0x43,
	0xfb, 0xc5, 0xf0, 0xb0, 0xc6, 0x6f, 0x3a, 0xeb, 0x57, 0x3a, 0xb3, 0xa4, 0x2b, 0x83, 0xbf, 0xff,
	0x5d, 0xeb, 0x06, 0x2e, 0xd1, 0x04, 0x56, 0xfe, 0x28, 0x1c, 0xc5, 0xde, 0xec, 0x19, 0xfd, 0xe7,
	0xe5, 0xd0, 0x3f, 0x2b, 0xa6, 0x07, 0xe1, 0xec, 0x87, 0xd3, 0x6b, 0x7f, 0x67, 0x98, 0x64, 0x0e,
	0xae, 0x7d, 0xff, 0xb7, 0x4c, 0x33, 0x72, 0x7d, 0xc2, 0xb2, 0x7f, 0x68, 0x41, 0x3c, 0x4c, 0x3c,
	0xd4, 0xff, 0x0c, 0x63, 0x33, 0x87, 0xb5, 0x7f, 0x7a, 0x42, 0xd5, 0x3b, 0xb9, 0xe0, 0x7a, 0x90,
	0xd7, 0x9a, 0xbf, 0xf6, 0x3e, 0xb9, 0xdd, 0x97, 0xc5, 0xa5, 0x7d, 0xac, 0xe7, 0xbf, 0x02, 0x00,
	0x00, 0xff, 0xff, 0xa5, 0x99, 0x90, 0x1f, 0x72, 0x03, 0x00, 0x00,
}
